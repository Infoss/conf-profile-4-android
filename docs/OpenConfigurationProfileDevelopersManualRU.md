# Руководство разработчика #

## Требования к стилю кода ##

В приложении встречается код, написанный на языках Java и C. В обоих случаях используется соглашение о т.н. "египетской" расстановке фигурных скобок (открывающая скобка ставится на той же строке, где объявляется элемент программы, к которому относится данный блок, а закрывающая - на отдельной строке), обрамляющих блоки кода.

Правильно:

    void foo() {
        bar();
    }

Неправильно:

    void foo()
    {
        bar();
    }


Код приложения на языке C написан с использованием объектно-ориентированного стиля, который принят в проекте [strongSwan](https://wiki.strongswan.org/projects/strongswan/wiki/ObjectOrientedC).

## Общая структура приложения Open Configuration Profile для Android ##
Open Configuration Profile для Android состоит из нескольких связанных между собой модулей. 

### Пользовательский интерфейс ###
Связь пользовательского интерфейса с модулем службы VPN (VpnManagerService) осуществляется с помощью механизма связывания (binding). Обычно для этих целей используется вспомогательны класс SimpleBindKit.

Отображение разнородных списков реализовано с помощью моделей, связывающих графическое представление элемента с его данными. Интерфейсы моделей и их простейшие реализации находятся в пакете `no.infoss.confprofile.model.common`.

Отображение списков реализовано с помощью сторонней библиотеки [android-classkit](https://github.com/demitsuri/android-classkit), которая предоставляет удобный API для связывания графического представления элемента списка с данными, которые ему соответствуют.

### Модуль службы VPN ###
Центральный модуль Open Configuration Profile для Android, выполняющий задачи управления предоставляемой платформой службой VPN, установления VPN-соединений, оценки условий и принятия решений установления соединения по запросу. Он также управляет состоянием подсистемы сбора отладочной информации (см. пункт "Дамп сетевого трафика") и оповещениями Android. Реализован в классе `no.infoss.confprofile.vpn.VpnManagerService`.

### Модуль маршрутизатора ###
Модуль маршрутизатора отвечает за перенаправление пакетов в разные VPN-туннели в зависимости от правил маршрутизации, которые задаются самими VPN-туннелями и/или модулем службы VPN. Выполняется в отдельном потоке, представляет собой бесконечный цикл, опрашивающий файловые дескрипторы VPN-туннелей. Реализован в классе `no.infoss.confprofile.vpn.RouterLoop`.

### Модуль IPSec (strongSwan) ###
Основан на [strongSwan](https://strongswan.org/) для Android. В Open Configuration Prodile для Android включается в виде динамически загружаемой библиотеки. Расширение функциональных возможностей модуля производится стандартным для strongSwan способом - посредством написания или адаптации плагина strongSwan.

### Модуль OpenVPN ###
Состоит из двух частей: клиентское приложение OpenVPN, собранное для платформы Android, и управляющий подмодуль, включённый в состав Open Configuration Profile для Android. Клиентское приложение запускается отдельным процессом. Связь с ним осуществляет управляющий подмодуль через [стандартный интерфейс взаимодействия](https://openvpn.net/index.php/open-source/documentation/miscellaneous/79-management-interface.html). Этот модуль является сильно переработанной версией приложения [ics-openvpn](https://code.google.com/p/ics-openvpn/).

### Модуль UserNAT ###
Этот модуль необходим для работы с соединениями, не попадающими в VPN-туннель. Поскольку для реализации функции "vpn on demand" требуется постоянно следить за исходящими соединениями, весь трафик направляется в модуль маршрутизатора. Для соединений, которые не должны попасть в активный VPN-туннель, реализуется имитация NAT, позволяющая отправить данные минуя туннелирование.


## Добавление поддержки нового типа полезной нагрузки профиля конфигурации (configuration profile payload) ##

Для добавления поддержки нового типа полезной нагрузки профиля конфигурации необходимо выполнить следующие действия:

1. Создать новый класс полезной нагрузки в пакете `no.infoss.confprofile.format`, унаследовав его от `no.infoss.confprofile.format.ConfigurationProfile.Payload`
2. В новом классе создать публичное статическое строковое поле `VALUE_PAYLOAD_TYPE`, и указать в нём тип полезной нагрузки
3. Реализовать все необходимые методы для быстрого доступа к полям полезной нагрузки
4. Зарегистрировать новый класс в статической секции фабрики `no.infoss.confprofile.format.PayloadFactory`

После этого при разборе полученного профиля конфигурации экземпляры класса нового типа полезной нагрузки будут создаваться автоматически.

## Добавление поддержки нового типа VPN-соединений ##

Для добавления поддержки нового типа VPN-соединений необходимо выполнить следующие действия:

1. Создать новый класс VPN-соединения в пакете `no.infoss.confprofile.vpn`, унаследовав его от `no.infoss.confprofile.vpn.VpnTunnel`
2. В созданном классе перегрузить метод `doEstablishConnection()` таким образом, чтобы в нём создавался контекст нового соединения (о контексте соединения см. ниже) и вызывался метод `startLoop()`
3. В созданном классе перегрузить метод `terminateConnection()` таким образом, чтобы установить статус `ConnectionStatus.TERMINATED` и деинициализировать контекст соединения
4. Контекст соединения представляет собой указатель на контекст туннеля в нативном коде. В большинстве случаев будет достаточно использовать [стандартный контекст туннеля](https://github.com/Maximus43/conf-profile-4-android/blob/develop/ConfProfile/jni/ocpa/tun.h)
5. Адаптировать код реализации VPN под использование внешнего файлового дескриптора как источника/получателя IP-датаграмм (см. использование указателя на функцию `getRemoteFd` в структуре контекста туннеля)
6. Обновить класс `no.infoss.confprofile.vpn.VpnTunnelFactory` таким образом, чтобы он создавал экземпляры нового класса VPN-соединения по его названию и сериализованным параметрам 

## Отладочные механизмы ##

В отладочную версию приложения включается набор дополнительных механизмов, облегчающий поиск ошибок в коде программы. В публикуемой версии приложения некоторые из этих механизмов деактивируются без возможности случайной или умышленной активации. 

### Лог VPN-туннеля ###
Для каждого туннеля ведётся отдельный протокол, помогающий установить причину неполадок при установке соединения. Протокол сохраняется в каталоге приложения на внешнем хранилище (обычно он находится по пути `/mnt/sdcard/Android/data/no.infoss.confprofile/files`). 

Файл протокола имеет имя `report-DDDD-(SSSS).log`, где DDDD - метка времени, а SSSS - строковый идентификатор туннеля.

При добавлении поддержки нового типа VPN-соединений требуется не допускать логгирование данных, содержащий секретные ключи, пароли и прочую конфиденциальную информацию.

Данный механизм присутствует и активирован как в отладочной, так и в публикуемой версии.
В отладочной версии приложения все поступившие в этот лог данные дублируются в лог операционной системы (logcat).

### Дамп сетевого трафика ###
Опция доступна с помощью соответствующего пункта меню на стартовом экране приложения. Выбранный режим работы (со включённым и выключенным дампом) сохраняется в настройках приложения.

В случае активации этой опции в каталог приложения на внешнем хранилище записываются файлы дампа сетевого трафика в формате pcap.

Для каждого туннеля создаётся отдельный файл дампа с именем `tun(SSSS)-DDDD.pcap`, где SSSS - строковый идентификатор туннеля, а DDDD - метка времени.

Для туннеля UserNAT создаётся файл дампа с именем `usernat(SSSS)-DDDD.pcap`, где SSSS - строковый идентификатор версии реализации UserNAT, а DDDD - метка времени.

Трафик, проходящий через точку обмена трафиком с Android VPN API, сохраняется в файле дампа с именем `router-DDDD.pcap`, где DDDD - метка времени.

Файлы в формате pcap можно открыть в программе Wireshark или любом другом анализаторе сетевого трафика. 

Дамп сетевого трафика доступен только в отладочной версии приложения. Сохранённые настройки этой опции не действуют в публикуемой версии приложения.